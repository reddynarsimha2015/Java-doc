{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Consolas;}{\f2\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue0;\red106\green62\blue62;\red127\green0\blue85;\red212\green212\blue212;\red0\green0\blue192;\red63\green127\blue95;\red42\green0\blue255;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang9\tab\tab\tab\tab Singleton Design Pattern\par
Singleton Definition\par
\b0 For any java class if we are allow to create only one object  such type of class is said to be singleton class\par
\b Advantage of Singleton class : \par
\b0 The main advantages of singleton  classes are Performance will be improved and memory utilization will be improved\par
\b Example\b0 -\par
DB class and Config Object\par
create DB config object once and use that object multiple time then we use concept called Singleton design pattern\par
\b Example\b0\par
class SingletonExample\{\par
//global initailization\par
static SingletonExample s=new SingletonExample();\par
private SingletonExample()\{\par
\}\par
static SingletonExample  getInstance()\{\par
return s;\par
\}\par
\}\par
\b\par
Step1 -problem  earily initalization\par
\b0 Global initalization-we create static instance class object inside of class  at classlevel .The class object load at time of classloading time then it is called earily Initalization.\par
Whenever we not  calling getInstance static method also  instance static class object  loaded  at time class loading.They no use of create object at time classloading time\par
To avoid problem\par
1) global static reference initailize with null;\par
2)create object inside the static getinstance method\par
Example\par
class SingletonExample\{\par
//global initailization\par
static SingletonExample s=null\par
private SingletonExample()\{\par
\}\par
static SingletonExample  getInstance()\{\par
if(s==null)\par
s=new SingletonExample ();\par
return s;\par
\}\par
\}\par
Above example is called lazy inialization.whenever we call getInstance  method that time object  created .\par
\par
\b Step2-problem   with inheritance\par
\b0 Here we can change object of classes  ,due to the  class inherited in another class \par
To avoid  this problem make class as final ,therefore the class cannot be inherited another classs\par
Excample\par
final public class SingletonExample\{\par
//global initailization with null\par
static SingletonExample s=null\par
private SingletonExample()\{\par
\}\par
static SingletonExample  getInstance()\{\par
if(s==null)\par
s=new SingletonExample ();\par
return s;\par
\}\par
\}\par
\b Step3-problem   with Reflection\b0\par
Reflection  api we can call private method,private constructor outside classs there it breaks \par
SingletonDesign  pattern\par
\b Example\b0\par
\cf1\f1\fs20 Constructor<SingletonDemo> \cf2 ss\cf1  = SingletonDemo.\cf3\b class\cf1\b0 .\highlight4 getDeclaredConstructor\highlight0 ();\cf0\par
\cf1\ul ss\ulnone .setAccessible(\cf3\b true\cf1\b0 );\cf0\par
\cf1 SingletonDemo \cf2 s3\cf1  = \cf2 ss\cf1 .newInstance();\cf0\par
\cf1 System.\cf5\b\i out\cf1\b0\i0 .println(\cf2 s3\cf1 .hashCode());\par
\b\f2\lang1033 To avoid this problem\par
\b0 create instance block  with check instance  object is present or not.if present throw exception that already the object created.\par
\cf0\b\f0\fs22\lang9 Example\b0\par
final public class SingletonExample\{\par
//global initailization with null\par
static SingletonExample s=null\par
private SingletonExample()throw Exception\{\par
\}\par
\{\par
if(s!=null)\par
throw new Exception("object already created");\par
\}\par
static SingletonExample  getInstance()throw Exception\{\par
if(s==null)\par
s=new SingletonExample ();\par
return s;\par
\}\par
\}\par
\cf1\f2\fs20\lang1033\par
\cf0\b\f0\fs22\lang9 Why  we create condition  instance block instead creating condition in  constructor?\par
\b0 Because when class have multiple construction we need write condition every time  in consturctor(duplication).To avoid writing condion multiple time in multiple constructor in clas ,just  keep thatcommon  condition in the instance block and  we can use mutiple constructor\par
\b Step3-problem   with  cloning\par
\b0 class should implment cloneable and override the clone method to avoid cloning  problem\par
\b Example\par
Test\par
\cf6\b0\f1\fs20 //cloning\cf0\par
\cf1 SingletonDemo \cf2 s4\cf1  = (SingletonDemo) \cf2 s3\cf1 .clone();\cf0\par
\cf1 System.\cf5\b\i out\cf1\b0\i0 .println(\cf2 s4\cf1 .hashCode());\par
\b\f2\lang1033 to avoid above problem  we override clone method and implements cloneable interface\cf0\b0\f0\fs22\lang9\par
final public class SingletonExample implements cloneable\{\par
//global initailization with null\par
static SingletonExample s=null\par
private SingletonExample()throw Exception\{\par
\}\par
static SingletonExample  getInstance()throw Exception\{\par
if(s==null)\par
s=new SingletonExample ();\par
return s;\par
\}\par
@Override\par
public Object clone()\{\par
return s;\par
\}\par
\}\par
\b Step4-problem   with  Deserilization\par
\b0 When we desialization new object created that which break the singletn Design pattern\par
to avoid this problem we going override \par
\b Example\par
Test\par
\cf6\b0\f1\fs20 //\ul Deserialization\cf0\ulnone\par
\cf6 //serializaion-convert object into bytes send over the network\cf0\par
\cf1\tab\tab FileOutputStream \cf2 fos\cf1  = \cf3\b new\cf1\b0  FileOutputStream(\cf7 "F:\\\\demo.txt"\cf1 );\cf0\par
\cf1\tab\tab ObjectOutputStream \cf2\ul o\cf1\ulnone  = \cf3\b new\cf1\b0  ObjectOutputStream(\cf2 fos\cf1 );\cf0\par
\cf1\tab\tab\cf2 o\cf1 .writeObject(\cf2 s\cf1 );\cf0\par
\cf6 //\ul deseralization\cf0\ulnone\par
\cf1\tab\tab FileInputStream \cf2 fis\cf1  = \cf3\b new\cf1\b0  FileInputStream(\cf7 "F:\\\\demo.txt"\cf1 );\cf0\par
\cf1\tab\tab ObjectInputStream \cf2\ul i\cf1\ulnone  = \cf3\b new\cf1\b0  ObjectInputStream(\cf2 fis\cf1 );\cf0\par
\cf1\tab\tab SingletonDemo \cf2 s3\cf1  = (SingletonDemo) \cf2 i\cf1 .readObject();\cf0\par
\cf1\tab\tab System.\cf5\b\i out\cf1\b0\i0 .println(\cf2 s3\cf1 .hashCode());\par
\b\f2\lang1033 To avoid this problem we override readSolve method.\cf0\b0\f0\fs22\lang9\par
final public class SingletonExample  extends Thread implements cloneable,Serilizable\{\par
//global initailization with null\par
static SingletonExample s=null\par
private SingletonExample()throw Exception\{\par
\}\par
static SingletonExample  getInstance()throw Exception\{\par
if(s==null)\par
s=new SingletonExample ();\par
return s;\par
\}\par
@Override\par
public Object clone()\{\par
return s;\par
\}\par
@Override\par
public Object readResolve()\{\par
return s;\par
\}\par
\}\par
\b Step5-problem   with  Multithread\par
\b0 final public class SingletonExample implements cloneable,Serilizable\{\par
//global initailization with null\par
static SingletonExample s=null\par
private SingletonExample()throw Exception\{\par
\}\par
static SingletonExample  getInstance()throw Exception\{\par
if(s==null)\par
s=new SingletonExample ();\par
return s;\par
\}\par
@Override\par
public Object clone()\{\par
return s;\par
\}\par
@Override\par
public Object readResolve()\{\par
return s;\par
\}\par
\cf3\b\f1\fs20 public\cf1\b0  \cf3\b void\cf1\b0  run() \{\cf0\par
\cf1\tab\cf3\b try\cf1\b0  \{\cf0\par
\cf1\tab\tab\tab SingletonDemo \cf2 s5\cf1  = SingletonDemo.\i getInstance\i0 ();\cf0\par
\cf1\tab\tab\tab System.\cf5\b\i out\cf1\b0\i0 .println(\cf2 s5\cf1 .hashCode());\cf0\par
\cf1\tab\tab\} \cf3\b catch\cf1\b0  (Exception \cf2 e\cf1 ) \{\cf0\par
\cf1\tab\tab\tab System.\cf5\b\i out\cf1\b0\i0 .println(\cf2 e\cf1 );\cf0\par
\par
\cf1\tab\tab\}\cf0\par
\cf1\tab\}\cf0\f0\fs22\par
public static void main(String[] args)\{\par
SingletonExample  s=new SingletonExample ();\par
s.start();\par
SingletonExample  s1=new SingletonExample ();\par
s1.start();\par
\}\par
\}\par
\b Here two thread run  parallel therefore it create new object for two threads.\par
To avoid this problem we going use synchronize block  and double check mechanism to avoid Singleton Design Pattern\par
\cf3\f1\fs20 static\cf1\b0  SingletonDemo getInstance() \cf3\b throws\cf1\b0  Exception \{\cf0\par
\par
\cf1\tab\tab\cf3\b if\cf1\b0  (\cf5\i s\cf1\i0  == \cf3\b null\cf1\b0 ) \{\cf0\par
\cf1\tab\tab\tab\cf3\b synchronized\cf1\b0  (SingletonDemo.\cf3\b class\cf1\b0 ) \{\cf0\par
\cf1\tab\tab\tab\tab\cf3\b if\cf1\b0  (\cf5\i s\cf1\i0  == \cf3\b null\cf1\b0 )\cf0\par
\cf1\tab\tab\tab\tab\tab\cf5\i s\cf1\i0  = \cf3\b new\cf1\b0  SingletonDemo();\cf0\par
\cf1\tab\tab\tab\}\cf0\par
\cf1\tab\tab\}\cf0\par
\par
\cf1\tab\tab\cf3\b return\cf1\b0  \cf5\i s\cf1\i0 ;\cf0\par
\cf1\tab\}\cf0\b\f0\fs22\par
This complete concept Singleton Design pattern.\b0\par
------------------------------------------------------------------------------------------------\par
\par
\par
\par
\par
}
 